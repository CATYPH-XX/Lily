Lily - статически-типизированный прототипно-ориентированный язык программирования.

типы данных:
- atom - 1 байт данных, может быть представлен в виде символа ASCII или числа в любом диапазоне. Если выйти за диапазон допустимых значений(0-255 для беззнаковых и -127-126 для знаковых) - компилятор выкинет предупреждение и отсечет старшие биты.
- object - объект. Является непрерывной областью в памяти. Он состоит из переменных или других объектов. Они иммутабельны(т.е. невозможно изменить их структуру(добавить новые элементы или убрать старые), но можно изменить содержание элементов). 
- void - нулевой тип. Означает отсутствие информации. Может содержаться в любой функции. Присвоение этому типу означает освобождение памяти.
- fn - функция. Может быть вызвана. По сути тоже является указателем. У каждой функции есть сигнатура, в которой указываются тип возвращаемого значения и аргументов.
- dynamic[T] - динамичный массив. Хранит в себе значения типа T.
- any - динамический тип. Может содержать в себе что угодно. 

Основные принципы языка:
- абсолютно все, в том числе функции, хранится в переменных.
- функции не видят внешние переменные(кроме глобальных). При передаче в функцию переменной передается указатель, а не данные. Это реализует безопасные сайд-эффекты.
- управление памятью автоматическое.
- все объекты имеют строго определенную неизменяемую структуру и размер.

HelloWorld на Lily:
```
main = fn()atom {
  std.print(std.string.new("Hello, world!"))
}
```
Для удобства можно опустить std.string.new и написать просто строковый литерал:
`std.print("Hello, world!")`


Объявление переменной:
`<тип данных> <имя> [инициализация]`
пример:
`atom var = 98`

Написание ключевого слова `const` перед объявлением переменной делает ее константной. Для каждого типа данных определено свое поведение:
- для atom и any запрещается изменять значение;
- для dynamic запрещается изменение элементов объекта(но не добавление или удаление);
- для object запрещается изменять содержание полей объекта;
- для fn запрещается переопределение функции.

Объявление функции:
`fn(аргументы)возвращаемое значение {тело}`
Пример:
```
fn(atom num1, atom num2)atom {
  return num1 + num2
}
```
Пример выше объявляет анонимную функцию. Чтобы дать ей имя, необходимо записать ее в переменную:
```
fn add = fn(atom num1, atom num2)atom {
  return num1 + num2
}
```

Объявление объекта:
```
object {
  atom x = 0
  atom y = 0
  object Color = object {
    atom r = 255
    atom g = 255
    atom b = 255
  }
  
  // ключевое слово this может использоваться
  // для указания родительского объекта
  // как типа
  fn move = fn(this obj, atom x, atom y)void {
    obj.x = x
    obj.y = t
  }
}
```
Опять же, объект выше анонимен. Чтобы дать ему имя, надо записать его в переменную:
`object Point = object { ... }`

Функции, находящиеся в объектах, могут называться методами.
Метод size() возвращает размер пространства в атомах. Переопределять его нельзя.
Сигнатура: `const fn size = fn()std.int`

Особые типы dynamic и any используются для динамики.
dynamic представляет из себя динамичный массив одного типа. Пример:
`dynamic[int] arr = {6, 1, 9}`
Тип any может хранить в себе значение любого типа. Пример:
```
any var = 46
var = object { x = 15 }
var = "str"

std.string str = var.cast(std.string)

std.print(str) 

var.cast(atom) // приведет к ошибке в рантайме
```
Для явного указания, что any относится к какому-то типу используется метод cast. *Внимание! невозможность привести тип вызовет ошибку в рантайме.*

Объекты также могут быть типами данных. Функции и методы могут использовать объекты как типы возвращаемых значений и аргументов. Чтобы считать объект `S` подходящим для типа данных `T`, у `S` должны быть все поля и методы `T`, плюс могут присутствовать свои методы и поля.
Пример:
```
object Animal = object {
  std.string name = "any animal"
  fn sound = fn()void {
    std.print("animal sound")
  }
}

object Dog = object {
  std.string name = std.string("Dog")
  fn sound = void() {
    std.print(std.string("Woof!"))
  }
}

fn sound = void(Animal animal) {
  animal.sound()
}

sound(Dog) // Woof!
```

Доступно встраивание:
```
object Dog = object {
  // добавление всех полей из Animal
  include Animal
    
  // переопределение метода
  fn sound = fn()void {
    std.print(std.string("Woof!"))
  }
}
```

Оператор include встраивает поля на этапе компиляции, объект не меняется в рантайме.

Объекты также можно использовать как пространства имен. Ключевое слово `use <объект>` позволяет использовать объект как пространство имен. Тогда можно будет напрямую использовать все поля(переменные) из этого объекта.
Пример:
```
use std

main = atom() {
  // не нужно писать
  // std. перед print
  print("Hello, world!")
    
  return 0
}
```

Существует особый объект _G, в него записываются все переменные, не входящие в функции или в другие объекты. Поля этого объекта доступны отовсюду в коде, в том числе в функциях. В _G также хранятся переменные типа:
- std - объект, содержащий стандартную библиотеку.
- main - функция, точка входа в программу. Изначально не инициализирована, нужно переопределить ее, чтобы программа компилировалась.



## ДЕТАЛИ РЕАЛИЗАЦИИ

В идеале язык должен компилироваться в чистый бинарный файл с исполняемым кодом без внешних зависимостей и Garbage Collector. На этапе компиляции не нужны сложные механизмы типа подсчета ссылок или анализа жизни переменных. Достигается это следующим образом:
Все переменные хранят указатели на данные. Сами же данные хранятся в куче. Хотя допускаются оптимизации, они рассматриваются отдельно, и мы пока что абстрагируемся от них и будем следовать жесткому принципу - все хранится в виде указателя.
В каждый момент времени на одни данные может указывать только 1 указатель. Исключение - передача аргумента в функцию.
У переменных нельзя менять адрес указателя, но можно данные по этому указателю. Исключение - операции с void.
Присвоение переменной значения void означает освобождение выделенной памяти. Присвоение какого-либо значения переменной, в которой лежит void, означает выделение памяти, запись указателя на начало памяти в переменную и копирование туда данных.
Присваивание означает копирование. Запись типа `y = x` означает "разыменовать x и положить полученное значение в адрес, на который указывает указатель в y.". В случае с объектами производится глубокое(рекурсивное) копирование.
Все глобальные переменные, находящиеся в объекте _G, хранятся в секции .bss программы. Локальные переменные(объявляемые в функциях) хранятся в стеке. Все данные хранятся в куче, все функции(исполняемый код) - в секции .text.
При передаче аргумента функции передается указатель, а не данные. Функция может свободно изменять данные, причем это отразится как побочный эффект. Тоже самое с возвращаемым значением - по сути, это такой же аргумент. При возврате функции вся память под локальные переменные(исключая аргументы и возвращаемое значение) рекурсивно освобождается.

Методы dynamic и any реализуются максимально просто - any хранит тип данных и сами данные, dynamic представляет простой динамический массив. В остальном на них действуют те же ограничения, что и выше.